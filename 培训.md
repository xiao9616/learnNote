# 2019年11月培训

## C++新特性及应用

### **1.nullptr**

 nullptr 出现的目的是为了替代 NULL,传统 C++ 会把 NULL、0 视为同一种东西。nullptr 关键字，专门用来区分空指针、0。nullptr的类型为nullptr_t。

```
void foo(char *);
void foo(int);
```

如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直观。

### **2.auto**

auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。

- auto 不能用于函数传参，考虑重载的问题，我们应该使用模板。

- auto 不能用于推导数组类型

  

```
std::vector<int> vec(5, 100);
for(vector<int>::const_iterator itr = vec.cbegin(); itr != vec.cend(); ++itr){
	
}
```

auto :

```
for(auto itr = vec.cbegin(); itr != vec.cend(); ++itr);
```

### **3. decltype**

声明返回类型

```
template<typename T1,typename T2>
auto add(T1 x,T2 y) ->decltype(x+y){
	return x+y;
}
```

编译器分析表达式并得到它的类型，却不实际计算表达式的值。

```
auto x = 1;
auto y = 2;
decltype(x+y) z;
```

### **4.foreach**

原来的for循环

```
std::vector<int> arr(5, 100);
for(std::vector<int>::iterator i = arr.begin(); i != arr.end(); ++i)
{
    std::cout << *i << std::endl;
}
```

现在

```
for(auto &i:arr)
{
    std::cout << i << std::endl;
}
```

### **5.初始化列表**

```
struct A
{
     int a;
     float b;
};
A a {1,1.0}；
A b{};  //初始化为0，指针初始化为nullptr
```

initializer_list

```
#include <initializer_list>
class Magic {
public:
    Magic(std::initializer_list<int> list) {
        for(auto &i:list){

        }
    }
};

Magic magic = {1,2,3,4,5};
std::vector<int> v = {1, 2, 3, 4};
max({1,2,3,4});
```

### **6.模板**

可变参数的模板

```
void print()
{

}

template<typename T,typename... Types>
void print(const T&  firstArgs,const Types&... args){
    cout<<firstArgs<<endk;
    print(args...);
}
```

类型别名模板

```
template< typename T, typename U, int value>
class SuckType {
public:
    T a;
    U b;
    SuckType():a(value),b(value){}
};

template <typename T>
using NewType = SuckType<int, T, 1>;    // 合法
```

默认模板参数

```
template<typename T = int, typename U = int>
auto add(T x, U y) -> decltype(x+y) {
    return x+y;
}
```

### **7.构造函数**

**委托构造**

使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的

```
class Base {
public:
    int value1;
    int value2;
    Base() {
        value1 = 1;
    }
    Base(int value) : Base() {  // 委托 Base() 构造函数
        value2 = 2;
    }
};
```

**继承构造**

有如下父类

```
class A
{
    A(int i) {}
    A(double d,int i){}
    A(float f,int i,const char* c){}
    //...等等系列的构造函数版本
}

```

原来子类继承父类，需要显式的调用父类构造函数，如下：

```
class  B:A
{
    B(int i):A(i){}
    B(double d,int i):A(d,i){}
    B(folat f,int i,const char* c):A(f,i,e){}
    //......等等好多个和基类构造函数对应的构造函数
}

```

现在可以这样：

```
class  B:A
{
    using A::A;
    //关于基类各构造函数的继承一句话搞定
}
```

### **8.Lambda**

```
f = lambda x, y, z :x+y+z
```

Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。

Lambda 表达式的基本语法如下：

```
[ caputrue ] ( params ) opt -> ret { body; };

1) capture是捕获列表； 
2) params是参数表；(选填) 
3) opt是函数选项；可以填mutable,exception,attribute（选填） 
mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。 
exception说明lambda表达式是否抛出异常以及何种异常。 
attribute用来声明属性。 
4) ret是返回值类型（拖尾返回类型）。(选填) 
5) body是函数体。

```

- 捕获列表：lambda表达式的捕获列表精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量。

  1) []不捕获任何变量。 
  2) [&]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。 
  3) [=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)。注意值捕获的前提是变量可以拷贝，且被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝。如果希望lambda表达式在调用时能即时访问外部变量，我们应当使用引用方式捕获。
  4) [=,&foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。 
  5) [bar]按值捕获bar变量，同时不捕获其他变量。 
  6) [this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&或者=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。

  ```
  class A
  {
   public:
       int i_ = 0;
  
       void func(int x,int y){
           auto x1 = [] { return i_; };                   //error,没有捕获外部变量
           auto x2 = [=] { return i_ + x + y; };          //OK
           auto x3 = [&] { return i_ + x + y; };        //OK
           auto x4 = [this] { return i_; };               //OK
           auto x5 = [this] { return i_ + x + y; };       //error,没有捕获x,y
           auto x6 = [this, x, y] { return i_ + x + y; };     //OK
           auto x7 = [this] { return i_++; };             //OK
  };
  
  int a=0 , b=1;
  auto f1 = [] { return a; };                         //error,没有捕获外部变量    
  auto f2 = [&] { return a++ };                      //OK
  auto f3 = [=] { return a; };                        //OK
  auto f4 = [=] {return a++; };                       //error,a是以复制方式捕获的，无法修改
  auto f5 = [a] { return a+b; };                      //error,没有捕获变量b
  auto f6 = [a, &b] { return a + (b++); };                //OK
  auto f7 = [=, &b] { return a + (b++); };                //OK
  ```

  

### **9.容器**

- array

std::array 保存在栈内存中，相比堆内存中的 std::vector，我们能够灵活的访问这里面的元素，从而获得更高的性能。编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array只需指定其类型和大小即可,但是必须用常量表达式来指明大小.

```
std::array<int, 4> arr= {1,2,3,4};
int len = 4;
std::array<int, len> arr = {1,2,3,4}; // 非法, 数组大小参数必须是常量表达式

```

- forward_list

std::forward_list 是一个列表容器，使用方法和 std::list 基本类似。 
和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一个不提供 size() 方法的容器。**当不需要双向迭代时，具有比 std::list 更高的空间利用率。**

- 无序容器

  std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。

  无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)。

- tuple

std::make_tuple: 构造元组

```
auto student=std::make_tuple(3.8, 'A', "张三");
```

std::tie: 元组拆包

```
std::tie(gpa, grade, name) = student;
```

std::get: 获得元组某个位置的值 

```
auto gpa=std::get<0>(student);
```

### **10.拷贝构造和转移构造**

```
string a(x);                                         // line 1
string b(x + y);                                    // line 2
string c(some_function_returning_a_string());       // line 3

```

第一行(line 1)的x是一个左值(lvalues）使用深度拷贝构造函数，如下：

```
string(const string& that)
{
    size_t size = strlen(that.data) + 1;
    data = new char[size];
    memcpy(data, that.data, size);
}

```

第二三行的参数是个右值，使用转移构造函数，如下：

```
string(string&& that)   // string&& is an rvalue reference to a string
{
data = that.data;
that.data = 0;
}

```

由于没有深度拷贝堆内存中的数据，而是仅仅复制了指针，并把源对象的指针置空。事实上，我们“偷取”了属于源对象的内存数据。由于源对象是一个右值，不会再被使用，因此客户并不会觉察到源对象被改变了。在这里，我们并没有真正的复制，所以我们把这个构造函数叫做“转移构造函数”（move constructor），他的工作就是把资源从一个对象转移到另一个对象，而不是复制他们。**编译器会依据参数是左值还是右值在复制构造函数和转移构造函数间进行选择。**

**拷贝构造函数执行的是深度拷贝，因为源对象本身必须不能被改变。而转移构造函数却可以复制指针，把源对象的指针置空，这种形式下，这是安全的，因为用户不可能再使用这个对象了。**

### **11.move转移左值**

标准库的头文件< utility >中提供了一个模板函数std::move。实际上，**std::move仅仅是简单地将左值转换为右值，它本身并没有转移任何东西。它仅仅是让对象可以转移。**

unique_ptr只有转移构造函数，如下：

```
unique_ptr(unique_ptr&& source)   // note the rvalue reference
{
    ptr = source.ptr;
    source.ptr = nullptr;
}

```

对unique_ptr对象进行赋值：

```
unique_ptr<Shape> a(new Triangle);
unique_ptr<Shape> b(a);              // still an error
unique_ptr<Shape> c(std::move(a));   // okay

```

第二行不能编译通过，因为a是左值，但是参数unique_ptr&& source只能接受右值。第三行编译没有问题，第三行之后，a不再拥有对象，通过move将a变为一个右值。

### **12.explicit**

构造器前面加上explicit修饰， 指定这个构造器只能被明确的调用/使用， 不能作为类型转换操作符被隐含的使用。**普通构造函数能够被隐式调用。而explicit构造函数只能被显式调用。**

```

class CxString  // 没有使用explicit关键字的类声明, 即默认为隐式声明  
{  
public:  
    char *_pstr;  
    int _size;  
    CxString(int size)  
    {  
        _size = size;                // string的预设大小  
        _pstr = malloc(size + 1);    // 分配string的内存  
        memset(_pstr, 0, size + 1);  
    }  
    CxString(const char *p)  
    {  
        int size = strlen(p);  
        _pstr = malloc(size + 1);    // 分配string的内存  
        strcpy(_pstr, p);            // 复制字符串  
        _size = strlen(_pstr);  
    }  
    // 析构函数这里不讨论, 省略...  
}; 

int main(){
	CxString string2 = 10; 
}
```

```
explicit CxString(int size)  
{  
    _size = size;  
    // 代码同上, 省略...  
} 
```

### **13.=default / =delete**

C++ 的类有四类特殊成员函数，它们分别是：默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符。

```
class A{
public:
    A() = default;
    A(const A& a) = default;
    A& operator=(A&);
    ~A() = default;
}
```

- 将该函数声明为 "=default"函数，编译器将为显式声明的 "=default"函数自动生成函数体。
- 在函数声明后上“=delete;”，就可将该函数禁用。

### **14.using**

- 命名空间 

  ```
  using namespace std;
  
  ```

- 声明

  ```
  using _basic::_M_allocate;
  
  ```

- 模板

  ```
  template<typename T>
  using mystring=basic_string<T,char_traits<T>>;
  
  ```

- 函数指针

  ```
  using func=void(*)(int,int);
  
  ```

### **15.noexcept**

条件为真时不抛出异常

```
void foo() noexcept(true){

}
```

### **16.override**

```
class base{
    virtual void func(float){

    }
}

class Devied:Base{
    virtual void func(float) override{
        //显示的声明为重写函数
    }
}

```

### **17.final**

作用与类上，表示类不可被继承

```
class Base final{

}

```

作用与虚函数上，表示该虚函数不可被重写

```
class Base{
    virtual void f() final;
}
```

### 18.智能指针

C++11引入智能指针，从此不用再需要手动释放内存。智能指针其实就是对普通指针的封装（即封装成一个类），通过重载 * 和 ->两个运算符，使得智能指针表现的就像普通指针一样。shared_ptr/unique_ptr/weak_ptr

**unique_ptr**

独占指针，不可进行拷贝或者赋值操作给其他智能指针，可以使用move转移所有权

```C++
unique_ptr<Monster> monster1(new Monster());	//monster1 指向 一个怪物 　　
unique_ptr<Monster> monster2 = monster1;		//Error!编译期出错，不允许复制指针指向同一个资源。
unique_ptr<Monster> monster3 = move(monster1);	//转移所有权给monster3. 　　
monster1->doSomething();					//Oops!monster1指向nullptr，运行期崩溃

```

**shared_ptr**

多个shared_ptr指向同一处资源，当所有shared_ptr都全部释放时，该处资源才释放。可以拷贝和赋值操作。

```
{
    shared_ptr<Monster> monster1(new Monster());　　　//计数加到1
	do{std::shared_ptr<Monster> monster2 = monster1;　　　　//计数加到2
	}while(0);　　　　　　　　　　
　　//该栈退出后，计数减为1，monster1指向的堆对象仍存在
	shared_ptr<Monster> monster3 = monster1;　//计数加到2
	shared_ptr<Monster> monster4 = monster1;　//计数加到3
}
//该栈退出后，shared_ptr都释放了，计数减为0，它们指向的堆对象也能跟着释放.

```

**weak_ptr**

是为了辅助shared_ptr的存在，它只提供了对管理对象的一个访问手段，同时也可以实时动态地知道指向的对象是否存活。要创建弱指针，必须是已经拥有资源但是是一个共享指针。weak_ptr只能用于跟踪一个共享的资源，但并不实际拥有，也不会阻碍资源的释放。读取共享资源前需要先执行lock，得到shared_ptr后才能进行访问。

```
shared_ptr<Monster> monster1(new Monster());
weak_ptr<Monster> r_monster1 = monster1;
r_monster1->doSomething();	//Error! 编译器出错！weak_ptr没有重载* 和 -> ，无法直接当指针用
shared_ptr<Monster> s_monster1 = r_monster1.lock();//OK!可以通过weak_ptr的lock方法获得shared_ptr。

```

### 19.cast类型转换

**static_cast**

内置基本数据类型之间的相互转换，enum、struct、 int、char、float等,涉及到类的话，static_cast只能在有相互联系的类型中进行相互转换,不一定包含虚函数。

```
int c=static_cast<int>(7.987);

class A
{};
class B:public A
{};
class C
{};
 
int main()
{
    A* a=new A;
    B* b;
    C* c;
    b=static_cast<B>(a);  // 编译不会报错, B类继承A类
    c=static_cast<B>(a);  // 编译报错, C类与A类没有任何关系
    return 1;
}

```

**const_cast**

仅仅把一个它作用的表达式转换成常量。它可以使一个本来不是const类型的数据转换成const类型的，或者把const属性去掉。

```
  int a = 10;
  const int *p = &a;    // 被const修饰，不能使用该指针修改其指向内容的值  
  int *q;
  q = const_cast<int *>(p);     // 去除p的常量性给q,如果不去除直接赋值会报错 
  *q = 20; 

```

**reinterpret_cast**

强制类型转换是一种非常强的强制类型转换，它可以将任意两个无关的指针或引用进行转换

**dynamic_cast**

static_cast会在编译的过程中进行安全性检查，而dynamic_cast会在运行的过程中进行安全性检查。这两个都带安全性检查可以防止错误的类型转换导致程序跑偏。



**总结**
static_cast会进行静态的安全性检查，一般用于内置数据类型的转换和通常的类之间的转换。
const_cast主要是用来去掉指针和引用的const和volatile类型。
reinterpret_cast用于完全没有关系指针或引用之间的转换，比如字符指针转整形指针。
dynamic_cast通常用于基类和派生类之间的相互转换。



# EffectiveC++

## 1.尽量使用const/enum/inline替代#define

1.1对于单纯常量，最好以const替换#define

```
#define PI 3.1415926

const float PI 3.1415926
```

1.2对于函数宏，最好使用inline函数替换#define

```
#define MAX（a，b） f((a)>(b)? (a):(b))

template<typename T>
inline void max(const T& a,const T& b)
{
    f(a>b ? a:b)
}
```

## 2.const

2.1const指针

const如果在星号左边，表示被指物为常量，如果在右边，表示为指针自身为常量

```
char* p					//no-const pointer,no-const data
const char* p			//no-const pointer,const data
char const * p			//no-const pointer,const data
char* const p			//const pointer , no-const data
const char* const p		//const pointer,const data
```

## 3.确保初始化

3.1构造函数member initialization list替换赋值操作

```
class people {
    int age;
    string name;
public:
	//成员初始化列表
    people(int age, const string &name) : age(age), name(name) {
        
    }
    //而不是赋值
    people(int age, const string &name) {
        age=age;
        name=name;
    }
};
```

## 4.拷贝构造/拷贝赋值构造/析构函数

4.1编译器会为空类声明拷贝构造/拷贝赋值构造/析构函数（只有需要的时候才会被创建），如果没有构造函数还会生成一个默认构造函数。

```
class people{
public:
    people(){}
    people(const people& p){}
    ~people(){}
    people& operator=(const people& p){}
}
```

4.2如果类包含引用或者const成员，则必须自己定义拷贝赋值构造函数。

4.3如果不需要编译器自己创建构造函数，可以自己声明为private，并且不要定义。

```
private:
people(const people&);
people& operator=(const people&);
```

4.3基类应该带有virtual析构函数，如果类中有任何virtual函数，则应该拥有一个virtual析构函数。如果希望该类不要派生了，则不要声明virtual析构函数。

4.4为了使得可以连续赋值，需要返回*this的引用

```
people p1,p2,p3;
p1=p2=p3;


people& operator=(const people& p){
	...
    return *this;
}
```

4.5保证自我赋值需要作证同测试,保证自己可以赋值给自己

```
people& operator=(const people& p){
	if(this=&p) return *this;
	delete data;
	data=new people(p.data);
    return *this;
}
```

## 5.资源管理

5.1auto_ptr 智能指针自动对所指向对象调用delete

```
auto_ptr<people> p=new people(),p1;
p1(p);	//p会变成null
```

如果通过拷贝构造函数，拷贝赋值构造函数赋值auto_ptr会使得他们变成null，拷贝对象获得资源唯一控制权

shared_ptr可以解决上述问题

```
shared_ptr<people> p=new people();
shared_ptr<people> p1（p）;
p1=p;	//p1和p指向同一对象
```

5.2new和delete成对使用

```
string* str1=new string;
string* str2=new string[100];

delete str1;
delete [] str2;
```

## 6.实现

6.1尽可能延后变量定义式的出现时间

```
string encrypyted;
if('''){
    throw logic_error("error")
}
return encryptyed;
```

上述代码如果抛出异常，则encryptyed没有被使用，需要承担构造和析构成本。应当延后定义，直到需要。

```
if('''){
    throw logic_error("error")
}
string encrypyted;
return encryptyed;
```

6.2尽量少转型

转型语法

```
(T) expression
T(expression)
const_cast<T> (expression)
dynamic_cast<T> (expression)
reinterpret_cast<T> (expression)
static_cast<T> (expression)
```

## 7.面向对象

7.1**public继承**意味着is-a

7.2继承类会遮掩基类的名称，可以使用using base：：使其重见天日

7.3可以为纯虚函数提供定义，但调用时必须明确指出其所属类的名称

```C++
class shape{
    public:
    	virtual void draw() const = 0;
}
void shape::draw(){
    cout<<"default draw"<<endl;
}

//main
shape* ps1=new rectangle();
ps1->draw();
ps1->shape::draw(); //调用纯虚函数默认的draw
```

但不建议这么做，使用虚函数可以同时实现声明接口和默认实现

纯虚函数只继承接口，虚函数继承接口和默认实现，非虚函数继承接口和强制实现

7.4不要重新定义继承来的non-virtual函数

```
class B{
    public:
    	void method();
}

class D;public B{
    public:
    	void method();
}

B* pb=new D;
D* pd=new D;
pb->method();	//调用B：：method
pd->method();	//调用D：：method
```

7.5 virtual是动态绑定，缺省参数是静态绑定，所以不要继承缺省参数

```C++
class shape{
public:
    	virtual void draw(color=red) const;
}

class rectangle:public shape{
public:
    virtual void draw(color=green) const;
}

shape* ps=new rectangle();
ps->draw();	//调用rectangle：：draw(red);
```

ps的静态类型是shape，动态类型是rectangle，缺省参数来自静态绑定

7.6non-virtual-interface(NVI)

```
class shape{
public:
    	void draw(color=red) const{
            doDraw();
    	}
private:
		virtual void doDraw() const{
            
		}
}

class rectangle:public shape{
private:
    virtual void doDraw const {
        
    }
}
```

7.7复合意味着has-a，意味着is-implemented-in-terms-of(根据某物实现出)

7.8 private继承意味着is-implemented-in-terms-of(根据某物实现），编译器不会对类型进行转化，继承的所有属性都会变成private，即使原来是protected/public

7.9多重继承比单一继承复杂，多重继承适用于public继承接口类/private继承实现类

## 8.模板与泛型

8.1隐式接口，编译时多态（template）

显式接口，运行时多态（virtual）

8.2typename标示类型名称,但不能在基类列和成员初始列中使用

```
template<typename T>
void print2d(const C& container){
    if(container.size()>=2){
        typename C::const_iterator iter(container.begin());
    }
}
```

### 9.位操作

```C
测试第 k 位: s & (1 << k)
设置第 k 位: s |= (1 << k)
第 k 位置零: s &= ~(1 << k)
切换第 k 位值: s ^= (1 << k)
乘以 2n: s << n
除以 2n: s >> n
交集: s & t
并集: s | t
减法: s & ~t
交换 x = x ^ y ^ (y = x)
取出最小非 0 位（Extract lowest set bit）: s & (-s)
取出最小 0 位（Extract lowest unset bit）: ~s & (s + 1)
交换值: x ^= y; y ^= x; x ^= y;
```

# More effective C++

### 1.指针和引用

1.1 指针和引用都是让你间接引用其他对象。由于不能使用指向空值的引用，所以当你用一个变量指向一个对象，但是该变量有时不会指向任何对象（空），这时应该把该变量声明为指针，反之应该使用引用。

```
string &rc;	//error

string s("zyx");
string &rs=s;	//good

string *ps；	//未初始化，合法但是危险
```

1.2 不存在空值引用意味着引用的代码效率更高，不需要检查合法性

```
void printDouble(const double &rd)
{
    cout<<rd;	// rd肯定指向一个double值
}


void printDouble(const double *rd)
{
	if(rd){
        cout<<*rd;	// rd需要检查是否为NULL
	}
    
}
```

1.3 指针可以被重新赋值，引用总是在初始化时被指定对象，不能改变

```
string s1("Nancy");
string s2("Xiao")；
string &rs=s1;
string *ps=&s1;

rs=s2;	//rs依旧引用s1，只是时s1的值变为Xiao
ps=&s2;	//ps指向s2，s1没有改变；
```

1.4 重载某个 操作符，应该使用引用。

```
vector<int> v(10);
v[5]=10;	//操作符[]返回引用

//如果[]返回一个指针，则应该这么写
*v[5] =10 ; //这样看上去是个向量指针，容易歧义，所以最好不要这样
```

在以下情况下你应该使用指针,一是你考虑到存在不指向任何对象的可能(在这种情况下,你能够设置指针为空),二是你需要能够在不同的时刻指向不同的对象(在这种情况下,你能改变指针的指向)。如果总是指向一个对象并且一旦指向一个对象后就不会改变指向,或者重载操作符时那么你应该使用引用。

### 2.尽量使用C++风格的类型转换

原来的类型转换（type）expression

```
（double）IntNums；
```

现在你应该这样写cast <type> (expression)

```
static_cast<double> IntNums;
```

2.1 static_cast

和C风格的类型转换一样，含义也一样。

```
int firstNumber,secondNumber;
double result=((double)firstNUmber)/secondNumber;	//C风格

double result=static_cast<double>(firstNumber)/secondNumber;	//C++风格
```

2.2 const_cast

const_cast用来转换const，volatile属性

```
//有如下定义
class Widget {};
class SpecialWidget:public Widget {};
void update(SpecialWidget *psw);

SpecialWidget sw;
const SpecialWidget &csw=sw;	//const引用

update(const_cast<SpecialWidget *>(&csw));	//正确 C++style
update((SpecialWidget *)&csw);	//正确 C style
update(& csw);	//错误，update不接受const变量
```

2.3 dynamic_cast

dynamic_cast把指向基类的指针或引用转换成指向派生类或其兄弟类型的指针或引用

```
Widget *pw;
void update(SpecialWidget *psw);
void updateViaRef(SpecialWidget &rsw)；

update(dynamic_cast<SpecialWidget *>(pw));
updateViaRef(dynamic_cast<SpecialWidget &>(*pw));
```

2.4 reinterpret_cast

reinterpret_cast最普遍的用途是在函数指针类型之间进行转换。

```
typedef void (*FuncPtr)();	//FuncPtr是一个指向函数的指针

FuncPtr funcPtrArray[10];	//funcPtrArray是个能容纳10个FuncPtr指针的数组

int doSomething();	//返回值为int的函数

funcPtrArray[0]=&doSomething；	//error
funcPtrArray[0]=reinterpret_cast<FuncPtr>(&doSomething);
```

### 3.不要对数组使用多态

类继承的最重要的特性是你可以通过基类指针或引用来操作派生类。这样的指针或引用
具有行为的多态性,就好像它们同时具有多种形态。

C++允许你通过基类指针和引用来操作派生类数组。不过这根本就不是一个特性,因为这样的代码几乎从不如你所愿地那样运行。

```
class BST { ... };
class BalancedBST: public BST { ... };

void printBSTArray(ostream& s,const BST array[],int numElements)
{
	for (int i = 0; i < numElements; ) {
			s << array[i];
	}
}

BST BSTArray[10];
printBSTArray(cout, BSTArray, 10);	// 运行正常

BalancedBST bBSTArray[10];
printBSTArray(cout, bBSTArray, 10);	// 可以正常编译，但是数值跳跃间隔还是sizeof(BST),不是BanlancedBST
```

### 4.避免无用的缺省构造函数

对于很多对象来说,不利用外部数据进行完全的初始化是不合理的。比如一个没有输入姓名的地址簿对象,就没有任何意义。在一些公司里,所有的设备都必须标有一个公司 ID 号码,所以在建立对象以模型化一个设备时,不提供一个合适的 ID 号码,所建立的对象就根本没有意义。

对于如下类：

```
class EquipmentPiece {
 public:
  EquipmentPiece(int IDNumber);
};
```

没有缺省构造函数，三种情况下会出现问题：

4.1 建立数组会出现问题

```
EquipmentPiece bestPieces[10];	//error 没有缺省构造函数
EquipmentPiece *bestPieces=new EquipmentPiece[10];	//error 没有缺省构造函数

1.定义时初始化
int ID1，ID2 ... ID10;
EquipmentPiece bestPieces[]={	//ok
    EquipmentPiece(ID1),
    .
    .
    EquipmentPiece(ID10)
}

2.使用指针数组
typedef EquipmentPiece* PEP；
PEP bestPieces[10];
for (int i = 0; i < 10; ++i)
	bestPieces[i] = new EquipmentPiece( ID Number );	//ok
```

4.2使用模板类会出现问题，因为实例化一个模板，模板类型应该提供一个默认构造函数。

```
//array类
template<class T>
class Array {
    public:
    Array(int size);
    ...
    private:
    T *data;
};
template<class T>
Array<T>::Array(int size)
{
    data = new T[size]; // 为每个数组元素依次调用 T::T()，需要T类型有缺省构造函数
}
```

4.3虚基类是否需要

派生类在实例化时都必须给虚基类构造函数提供参数。这就要求所有由没有缺省构造函数的虚基类继承下来的派生类(无论有多远)都必须知道并理解提供给虚基类构造函数的参数的含义。

```
class EquipmentPiece {
    public:
    EquipmentPiece( int IDNumber = UNSPECIFIED);

    private:
    static const int UNSPECIFIED;
};

这允许这样建立 EquipmentPiece 对象
EquipmentPiece e; 	//这样合法
```

这样的修改使得其他成员函数变得复杂,因为不再能确保 EquipmentPiece 对象进行了有意义的初始化。

### 5.类型转换函数

C++编译器能够在两种数据类型之间进行隐式转换，允许把 char 隐式转换为 int 和从short 隐式转换为 double，这种可怕的转换可能会导致数据的丢失。

你自己可以定义转换构造函数进行这些转换：单参数构造函数和显式类型转换函数

5.1单参数构造函数

```
class Name {
    // for names of things
    public:
    Name(const string& s);	// 转换 string 到Name
};
```

5.2显式类型转换函数

```
class Rational {
    // 有理数类
    public:
        Rational(int numerator = 0,
        int denominator = 1);// 转换 int 到有理数类
        double asDouble() const;
};

Rational r(1,2);
cout<<r.adDouble();
```

为了解决隐式类型转换，加入了关键字explicit

```
template<class T>
class Array {
    public:
      explicit Array(int size);	//explicit 使得编译器会拒绝为了隐式类型转换而调用构造函数
};
```

### 6.自增，自减的前缀和后缀

重载++，--，为了区分前后缀差异，规定后缀形式有一个 int 类型参数,当函数被调用时,编译器传递一个 0 做为 int 参数的值给该函数。

```
class UpInt{
    public:
    	UpInt &operator++();	//前缀
    	const UpInt operator++(int);后缀
    	UpInt &operator+=(int);	
}

UpInt &UpInt::operator++()
{
    *this+=1;
    return *this;
}


const UpInt UpInt::operator++(int)
{
    UpInt oldValue=*this;
    ++(*this);
    return oldValue;
}
```

### 7.尽量不要重载&&，||，‘，’

C++使用布尔表达式短路求值法，一旦确定了布尔表达式的真假值,即使还有部分表达式没有被测试,布尔表达式也停止运算。

如果重载了&&，||的话，不能保证还能满足短路求值法，使得使用它的程序员会困惑。

### 8.new/delete的不同含义

new操作符，这个操作符就象 sizeof 一样是语言内置的,你不能改变它的含义,它的功能总是一样的。它要完成的功能分成两部分。第一部分是分配足够的内存以便容纳所需类型的对象。第二部分是它调用构造函数初始化内存中的对象。

```
string *ps=new string("Memory Management");
```

new操作，new 操作符调用一个函数来完成必需的内存分配,你能够重写或重载这个函数来改变它的行为。new 操作符为分配内存所调用函数的名字是 operator new。通常如下声明：

```
void *operator new(size_t size);
```

new 操作符实际进行了如下的过程：

```
void *memory=operator new(sizeof(string));
call string("Memory Management") on memory;
string *ps=static_cast<string *>(memory);
```

### 9.利用析构函数防止资源泄露

```
while (dataSource) {
    ALA *pa = readALA(dataSource);
    pa->processAdoption(); //处理收容动物
    delete pa; //删除 readALA 返回的对象
}
```

上述代码如果载pa->processAdoption()中发生异常，则pa占用资源就不会被释放，造成内存泄露

使用智能指针可以解决这个问题，使用一个对象代替指针。

```
template<class T>
class auto_ptr {
    public:
        auto_ptr(T *p = 0): ptr(p) {} // 保存 ptr,指向对象
        ~auto_ptr() { delete ptr; } // 删除 ptr 指向的对象
    private:
        T *ptr;
};
```

用 auto_ptr 对象代替 raw 指针,你将不再为堆对象不能被删除而担心,即使在抛出异常时,对象也能被及时删除。

```
while (dataSource) {
    auto_ptr<ALA> pa(readALA(dataSource));
    pa->processAdoption();
}
```

pa 被声明为一个 auto_ptr<ALA>对象,而不是一个指针,所以会被当作局部变量被释放，自动调动析构函数。而他的行为却和指针一样。

auto_ptr 后的思想是:用一个对象存储需要被自动释放的资源,然后依靠对象的析构函数来释放资源,这种思想不只是可以运用在指针上,还能用在其它资源的分配和释放上。

### 10.在构造函数中防止资源泄露

考虑如下的构造函数：

```
//声明
BookEntry(const string& name,
		  const string& address = "",
          const string& imageFileName = "",
          const string& audioClipFileName = "");
//定义
BookEntry::BookEntry(const string& name,
                     const string& address,
                     const string& imageFileName,
                     Const string& audioClipFileName)
: theName(name), theAddress(address),
theImage(0), theAudioClip(0)
{
    if (imageFileName != "") {
        theImage = new Image(imageFileName);
    }
    if (audioClipFileName != "") {
        theAudioClip = new AudioClip(audioClipFileName);
    }
}

BookEntry::~BookEntry()
{
    delete theImage;
    delete theAudioClip;
}
```

如果AudioClip 的构造函数自己抛出一个异常，那么谁来负责删除 theImage 已经指向的对象?

```
BookEntry *pb = 0;
try {
    pb = new BookEntry("Addison-Wesley Publishing Company",
    "One Jacob Way, Reading, MA 01867");
    ...
    }
catch (...) {
    // 捕获所有异常
    delete pb; // 删除 pb,当抛出异常时
    throw; // 传递异常给调用者
    }
delete pb;
```

你会发现在 BookEntry 构造函数里为 Image 分配的内存仍旧被丢失了,这是因为如果new 操作没有成功完成,程序不会对 pb 进行赋值操作。

```
try {
    if (imageFileName != "") {
        theImage = new Image(imageFileName);
    }
    if (audioClipFileName != "") {
        theAudioClip = new AudioClip(audioClipFileName);
    }
}
catch (...) {
    delete theImage;
    // 捕获所有异常
    // 完成必要的清除代码
    delete theAudioClip;
    throw;
}
```

修改构造函数如上，但这样做不太完美。

如果theImage 和 theAudioClip 是常量(constant)指针类型，必须通过 BookEntry 构造函数的成员初始化表来初始化这样的指针。

```
Image * const theImage; // 指针现在是
AudioClip * const theAudioClip; // const 类型
```

通常需要这样初始化

```
BookEntry::BookEntry(const string& name,
                     const string& address,
                     const string& imageFileName,
                     const string& audioClipFileName)
: theName(name), theAddress(address),
  theImage(imageFileName != "" ? new Image(imageFileName): 0),
  theAudioClip(audioClipFileName != "" ? new AudioClip(audioClipFileName): 0)
{}
```

这样做导致我们原先一直想避免的问题重新出现:如果 theAudioClip 初始化时一个异常被抛出,theImage 所指的对象不会被释放。

可以考虑用函数返回指针指向初始化过的 theImage 和 theAudioClip 对象。

```
BookEntry::BookEntry(const string& name,
                     const string& address,
                     const string& imageFileName,
                     const string& audioClipFileName)
: theName(name), theAddress(address),
  theImage(initImage(imageFileName)),
  theAudioClip(initAudioClip(audioClipFileName))
{}

Image * BookEntry::initImage(const string& imageFileName)
{
    if (imageFileName != "") return new Image(imageFileName);
    // theAudioClip 被第二个初始化, 所以如果在 theAudioClip
	// 初始化过程中抛出异常,它必须确保 theImage 的资源被释放。
    else return 0;
}

AudioClip * BookEntry::initAudioClip(const string&audioClipFileName)
{
    try {
        if (audioClipFileName != "") {
        return new AudioClip(audioClipFileName);
        }
        else return 0;
    }
    catch (...)
    {
        delete theImage;
        throw;
    }
}
```

现在这个思想很类似与智能指针，但是这样代码难以管理

```
const auto_ptr<Image> theImage;			// 它们现在是
const auto_ptr<AudioClip> theAudioClip; // auto_ptr 对象

BookEntry::BookEntry(const string& name,
                     const string& address,
                     const string& imageFileName,
                     const string& audioClipFileName): theName(name), theAddress(address),
theImage(imageFileName != "" ? new Image(imageFileName): 0),
theAudioClip(audioClipFileName != "" ? new AudioClip(audioClipFileName): 0)
{}
```

用对应的 auto_ptr 对象替代指针成员变量,就可以防止构造函数在存在异常时发生资源泄漏,你也不用手工在析构函数中释放资源。

在对象构造中,处理各种抛出异常的可能,是一个棘手的问题,但是 auto_ptr(或者类似于 auto_ptr 的类)能化繁为简。它不仅把令人不好理解的代码隐藏起来,而且使得程序在面对异常的情况下也能保持正常运行。

### 11.禁止将异常传递到析构函数之外

如果析构函数本身的调用就是源自于某些其它异常的抛出,那么 terminate 函数将被自动调用,彻底终止你的程序。

对于析构函数可能发生异常的情况，应该在可能发生异常的地方使用try-catch

```
Session::~Session()
{
    try {
        logDestruction(this);
    }
    catch (...) { }
}
```

catch 表面上好像没有做事情 , 这是一个假象 , 实际上它阻止了任何从logDestruction 抛出的异常被传递到析构函数的外面。

不允许异常传递到析构函数外面还有第二个原因。如果一个异常被析构函数抛出而没有在函数内部捕获住,那么析构函数就不会完全运行。

### 12.catch的参数是拷贝过来的

1.参数是拷贝过来的

```
//class Widget {}

void passThorwWidget()
{
    Widget localWidget;
    throw localWidget;
}

catch (Width &w)
catch (Width *w)
catch (Width w)
```

不论通过传值捕获异常还是通过引用捕获(不能通过指针捕获这个异常,因为类型不匹配)都将进行 lcalWidget 的拷贝操作,也就说传递到 catch子句中的是 localWidget 的拷贝。必须这么做,因为当 localWidget 离开了生存空间后,其析构函数将被调用。如果把 localWidget 本身(而不是它的拷贝)传递给 catch 子句,这个子句接收到的只是一个被析构了的 Widget,一个 Widget 的“尸体”。这是无法使用的。

2.异常对象被拷贝是其静态类型

```
void passAndThrowWidget()
{
    SpecialWidget localSpecialWidget;

    Widget& rw = localSpecialWidget;	// rw 引用 SpecialWidget
    throw rw;	//它抛出一个类型为 Widget的异常
}
```

3.

```
catch (Widget& w)	// 捕获 Widget 异常
{
    ... // 处理异常
    throw; // 重新抛出异常,让它继续传递
} 
catch (Widget& w) // 捕获 Widget 异常
{
    ... // 处理异常
    throw w; // 传递被捕获异常的拷贝
}
```

4.一般来说,catch 子句匹配异常类型时不会进行隐式转换。

```
try {
    int	value；
    if (someFunction()) {
    throw value;	// 如果 someFunction()返回真,抛出一个整形值
}
}
catch (double d) {	// 只处理 double 类型的异常
...
}
```

不过在 catch 子句中进行异常匹配时可以进行两种类型转换。第一种是继承类与基类间的转换。一个用来捕获基类的 catch 子句也可以处理派生类类型的异常。

第二种是允许从一个类型化指针(typed pointer)转变成无类型指针(untyped pointer),所以带有 const void* 指针的 catch 子句能捕获任何类型的指针类型异常:

```
catch (const void*) 			//捕获任何指针类型异常
```

5.catch 子句匹配顺序总是取决于它们在程序中出现的顺序，一个派生类异常可能被处理其基类异常的 catch 子句捕获。

```
try {
...
}

catch (logic_error& ex) {
   // 这个 catch 块 将捕获所有的 logic_error异常, 包括它的派生类
} 

catch (invalid_argument& ex) { // 这个块永远不会被执行
	//invalid_argument是logic_error的派生类
}
```

所以不要把处理基类异常的 catch 子句放在处理派生类异常的 catch 子句的前面，上面的catch块应该反过来

### 13.通过引用reference捕获异常

当你写一个 catch 子句时,必须确定让异常通过何种方式传递到 catch 子句里。你可以有三个选择:与你给函数传递参数一样,通过指针(by pointer),通过传值(by value)或通过引用(by reference)。

1.通过指针

理论上这种方法的实现对于这个过程来说是效率最高的。因为在传递异常信息时,只有采用通过指针抛出异常的方法才能够做到不拷贝对象

```
void someFunction(){
    exception ex;
    throw &ex;	//抛出一个指针
}
```

这简直糟糕透了,因为处理这个异常的 catch 子句接受到的指针,其指向的对象已经不再存在。全局与静态对象都能够做到这一点,但是程序员很容易忘记这个约束。

2.值传递

当它们被抛出时系统将对异常对象拷贝两次，派生类的异常对象被做为基类异常对象捕获时,那它的派生类行为就被切掉了

3.引用

通过引用捕获异常能使你避开上述所有问题。不象通过指针捕获异常,这种方法不会有对象删除的问题而且也能捕获标准异常类型。也不象通过值捕获异常,这种方法没有 slicing problem,而且异常对象只被拷贝一次。

### 14.尽量使用构造的方式返回值

1.返回指针

```
const Rational * operator*(const Rational& lhs,const Rational& rhs);
```

这样的调用会很滑稽，而且调用者需要删除函数返回的指针，否则会造成内存泄露。

```
Rational a = 10;
Rational b(1, 2);
Rational c = *(a * b);
delete c;
```

2.返回引用

```
const Rational& operator*(const Rational& lhs,const Rational& rhs)
{
    Rational result(lhs.numerator() * rhs.numerator(),
    lhs.denominator() * rhs.denominator());
    return result;//返回时,其指向的对象已经不存在了
}
```

3.返回对象

一种高效的做法是，利用构造返回一个对象，而不是直接返回

```
const Rational operator*(const Rational& lhs,const Rational& rhs)
{
    return Rational(lhs.numerator() * rhs.numerator(),
    				lhs.denominator() * rhs.denominator());
}
```

### 15.使用重载避免隐式类型转换

对于如下类：

```
class UPInt { 
    public: // integers 类
        UPInt();
        UPInt(int value);
};
const UPInt operator+(const UPInt& lhs, const UPInt& rhs)
```

对于如下操作：

```
UPInt upi1, upi2，upi3;
upi3=upi1+10；
upi3=10+upi2；
```

这些语句也能够成功运行。方法是通过建立临时对象把整形数 10 转换为 UPInts，但是建立临时对象进行隐式类型转换是有代价的，我们不想要这种开销。

所以要实现这种功能，重载是个好办法

```
const UPInt operator+(const UPInt& lhs,const UPInt& rhs);
const UPInt operator+(const UPInt& lhs,int rhs);
const UPInt operator+(int lhs,const UPInt& rhs);
```

不要重载如下的函数：

```
const UPInt operator+(int lhs, int rhs);
```

这是因为每一个重载的 operator 必须带有一个用户定义类型(user-defined type)的参数。

### 16.+=还是=？

operator+ 根据 operator+=实现的

```
const Rational operator+(const Rational& lhs,const Rational& rhs)
{
	return Rational(lhs) += rhs;
}

const Rational operator-(const Rational& lhs,const Rational& rhs)
{
	return Rational(lhs) -= rhs;
}
```

总的来说 operator 的赋值形式（+=）比其单独形式（+）效率更高,因为单独形式要返回一个新对象,从而在临时对象的构造和释放上有一些开销。赋值形式把结果写到左边的参数里,因此不需要生成临时对象来容纳 operator 的返回值。

但是这样会带来调用的复杂性

```
Rational a, b, c, d, result;
result = a + b + c + d;	//单独形式
 
result = a; 
result += b;	//赋值形式 
result += c; 
result += d;
```

### 17.理解虚函数

虚函数类在机理是使用 virtual table （vtbl）和 virtual table pointers（vptr）

一个vtbl通常是一个函数指针数组，程序中只要有虚函数或者继承了虚函数，就会有自己的vtbl。类中vtbl是指向虚函数实现的指针数组。

```
class C1 {
    public:
        C1();
        virtual ~C1();
        virtual void f1();
        virtual int f2(char c) const;
        virtual void f3(const string& s);
        void f4() const;
};
```

虚函数所需的第一个代价:你必须为每个包含虚函数的类的 virtualtalbe 留出空间。类的 vtbl 的大小与类中声明的虚函数的数量成正比。

Virtual table 只实现了虚拟函数的一半机制,如果只有这些是没有用的。只有用某种方法指出每个对象对应的 vtbl 时,它们才能使用。这是 virtual table pointer 的工作,它来建立这种联系。

虚函数所需的第二个代价是:在每个包含虚函数的类的对象里,你必须为额外的指针付出代价。

![原理图](/home/560204/gitee/LearnNote/cpp/cppAdvance/effectiveCpp/vptr.png)

虚函数不能是内联的。这是因为“内联”是指“在编译期间用被调用的函数体本身来代替函数调用的指令,”但是虚函数的“虚”是指“直到运行时才能知道要调用的是哪一个函数。

虚函数所需的第三个代价:你实际上放弃了使用内联函数。

### 18.智能指针

智能指针从模板中生成，大多数看起来如下：

```
template<class T>
class SmartPtr {
    public:
        SmartPtr(T* realPtr = 0);
        SmartPtr(const SmartPtr& rhs);
        ~SmartPtr();// 释放灵巧指针
        SmartPtr& operator=(const SmartPtr& rhs);
        T* operator->() const;// dereference 一个灵巧指针
        T& operator*() const;// dereference 灵巧指针
    private:
        T *pointee;// 灵巧指针所指的对象
};
```

T& operator->() const;

```
template<class T>
T& SmartPtr<T>::operator*() const
{
    //perform "smart pointer" processing;
    return *pointee;
}
```

### 19.C/C++混合使用需要解决的问题

1.函数同名的问题

由于C++存在函数重载，所以会有许多同名的函数，编译器为了给予区分，在编译过程中会对函数名进行名变换。因为链接程序通常无法分辨同名的函数，所以名变换是对链接程序的妥协，而C的编译器没有这种功能。

c++中有一个函数叫 drawline 而编译器将它变换为 xyzzy,你总使用名字 drawLine,不会注意到背后的 obj 文件引用的是 xyzzy的。但如果 drawLine 是一个 C 函数,obj 文件(或者是动态链接库之类的文件)中包含的编译后的 drawLine 函数仍然叫 drawLine;没有名变换动作。当你试图将 obj 文件链接为程序时,将得到一个错误,因为链接程序在寻找一个叫 xyzzy 的函数,而没有这样的函数存在。

要解决这个问题,你需要一种方法来告诉 C++编译器不要在这个函数上进行名变换。

要禁止名变换,使用 C++的 extern 'C'指示:

```
extern “C”
void drawLine(int x1, int y1, int x2, int y2);
```

你甚至可以在 C++函数上申明 extern 'C'

```
extern “C” void twiddleBits(unsigned char bits);
```

经常,你有一堆函数不想进行名变换,为每一个函数添加 extern 'C'是痛苦的。幸好,这没必要。extern 'C'可以对一组函数生效,只要将它们放入一对大括号中

```
extern "C" {
    void drawLine(int x1, int y1, int x2, int y2);
    void twiddleBits(unsigned char bits);
    void simulate(int iterations);
}
```

当用C++编译时,你应该加 extern 'C',但用 C 编译时,不应该这样。通过只在 C++编译器下定义的宏__cplusplus,你可以将头文件组织得这样

```
#ifdef __cplusplus
extern "C" {
#endif
    void drawLine(int x1, int y1, int x2, int y2);
    void twiddleBits(unsigned char bits);
    void simulate(int iterations);
#ifdef __cplusplus
}
#endif
```

2.静态初始化

为了解决 main()应该首先被调用,而对象又需要在 main()执行前被构造的两难问题,许多编译器在 main()的最开始处插入了一个特别的函数,由它来负责静态初始化。

```
int main(int argc, char *argv[])
{
    performStaticInitialization();
    the statements you put in main go here;
    performStaticDestruction();
}
```

所以只要程序的任意部分是 C++写的,你就应该用 C++写 main()函数

为了少改动程序，将C 写的 main()改名为 realMain(),然后用 C++版本的 main()调用realMain():

```
extern "C"
int realMain(int argc, char *argv[]); // function in C
int main(int argc, char *argv[]) // write this in C++
{
    return realMain(argc, argv);
}
```

3.数据兼容

将在两种语言间传递的东西限制在用 C 编译的数据结构的范围内;这些结构的 C++版本可以包含非虚成员函数。

# C++编程思想

[TOC]

## 第一部分

## 第二部分

### 1.设计模式

#### 1.1创建型模式

##### 1.1.1单例模式

单例模式用来控制类只能产生一个实例对象

实现单例的步骤
1.构造函数私有化
2.增加私有静态的当前类的指针变量
3.提供静态的对外接口

```
class A {
private:
    A() { }
public:
    static A *getInstace() {
        return a;
    }
private:
    static A *a;
};
A *A::a = NULL;
```

懒汉式：需要时再创建

```
class singLazzy {
private:
    singLazzy() {cout<<"singlelazzy"<<endl;}

public:
    static singLazzy *getInstace() {
        if (singleton == NULL) {
            singleton = new singLazzy;
        }
        return singleton;
    }
    static void freeSpace(){
        if (singleton != NULL) {
            delete singleton;
            cout<<"空间已经释放"<<endl;
        }
    }

private:
    static singLazzy *singleton;
};

singLazzy *singLazzy::singleton = NULL;
```

饿汉式:类初始化就创建对象

```
class singleHungry{
private:
    singleHungry(){cout<<"singlehungry"<<endl;};
public:
    static singleHungry* getInstace(){
        return singlehun;
    }

private:
    static singleHungry* singlehun;
};

singleHungry* singleHungry::singlehun=new singleHungry;
```

##### 1.1.2工厂模式

提供了一种创建对象的最佳方式，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

```
class abstractFruit {
public:
    virtual void showName() = 0;
};

class apple : public abstractFruit {
public:
    virtual void showName() {
        cout << "我是苹果" << endl;
    }
};

class banana : public abstractFruit {
public:
    virtual void showName() {
        cout << "我是香蕉" << endl;
    }
};

class pear : public abstractFruit {
public:
    virtual void showName() {
        cout << "我是梨" << endl;
    }
};

class fruitFactory {
public:
    static abstractFruit *creatFruit(string name) {
        if (name == "apple") {
            return new apple;
        }
        if (name == "banana") {
            return new banana;
        }
        if (name == "pear") {
            return new pear;
        } else {
            return NULL;
        }
    }
};

int main() {
    fruitFactory *factory = new fruitFactory;
    abstractFruit *apple = factory->creatFruit("apple");
    apple->showName();
    return 0;
}
```

##### 1.1.3抽象工厂模式

围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

```
class abstractFactory {
public:
    virtual abstractFruit *createFruit() = 0;
};

......

class applefactory : public abstractFactory {
    virtual abstractFruit *createFruit() {
        return new apple;
    }
};

class bananafactory : public abstractFactory {
    virtual abstractFruit *createFruit() {
        return new banana;
    }
};

class pearfactory : public abstractFactory {
    virtual abstractFruit *createFruit() {
        return new pear;
    }
};
```

##### 1.1.4建造者模式

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。

```
class Packing {
    public:
        virtual string pack() {return "";}
};

class Wraper : public Packing {
    public:
    	string pack() {return "纸包装的食物";}
};

class Botton : public Packing {
    public:
    	string pack() {return "竹子包装的食物";}
};

class Item {
    public:
        virtual string name() = 0;
        virtual Packing *packing() = 0;
        virtual float price() = 0;
};

class Burger : public Item {
	public:	
		float price() {return 17.5;	}	
		Packing *packing() {
			Packing *pack = new Wraper();
			return pack;
		}	
        string name() {	
        	string n = "这是堡";
        	return n;
		}
};

class Drunk : public Item {
	public:	
		float price() {return 10.0;	}	
		Packing *packing() {
			Packing *pack = new Botton();
			return pack;
		}	
        string name() {	
        	string n = "这是饮料";
        	return n;
		}
};

class vegBurger : public Burger {
	public:	
		float price() {return 12.5;	}	
        string name() {	
        	string n = "这是蔬菜堡";
        	return n;
		}
};
```

##### 1.1.5原型模式

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。针对一个多个相似对象的情况，提供一个快速生成对象的方式。

本例中同一电脑，只有品牌是不同的，其他参数都是一样的。那我们就可以先用一个正常的对象，克隆出新的对象，然后再微调新对象的特殊属性。这样就达到快速生成相似对象的方法。

```
class Computer
{
public:
    void SetBrandName(string brandName)         //设置品牌
    {
        this->m_BrandName = brandName;
    }

    void SetCpu(string cpu)                     //设置CPU
    {
        this->m_Cpu = cpu;
    }

    void SetMemory(string memory)               //设置内存
    {
        this->m_Memory = memory;
    }

    void SetVideoCard(string videoCard)        //设置显卡
    {
        this->m_VideoCard=videoCard;
    }


    Computer Clone()                               //克隆函数
    {
        Computer ret;
        ret.SetBrandName(this->m_BrandName);
        ret.SetCpu(this->m_Cpu);
        ret.SetMemory(this->m_Memory);
        ret.SetVideoCard(this->m_VideoCard);
        return ret;
    }
    private:
    string m_BrandName;                         //品牌
    string m_Cpu;                               //CPU
    string m_Memory;                            //内存
    string m_VideoCard;                         //显卡
};

int main()
{
    Computer asusComputer;
    asusComputer.SetBrandName("华硕");
    asusComputer.SetCpu("I7 8700");
    asusComputer.SetMemory("16g");
    asusComputer.SetVideoCard("gtx 1080 ti");
    asusComputer.ShowParams();
    
     //再生产宏基电脑
    Computer acerComputer = asusComputer.Clone();
    acerComputer.SetBrandName("宏基");
}
```



#### 1.2结构型模式

##### 1.2.1 适配器模式

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。

Adaptee类没有Request方法，而客户期待这个方法。为了使客户能够使用Adaptee类，提供一个中间环节，即类Adapter类，Adapter类实现了Target接口，并继承自Adaptee，Adapter类的Request方法重新封装了Adaptee的SpecificRequest方法，实现了适配的目的。

```
class Target{
    public:
		virtual void Request(){}
};

class Adaptee{
    public:
    	void SpecificRequest(){}
};

class Adapter:public Adaptee,public Target
{
    void Request(){
        this->SpeciaficRequest();
    }
};

int main(){
    Target *t=new Adapter();
    t->Requeset();
}

```

##### 1.2.2 装饰器模式

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。可以动态的给对象添加额外的职责或者功能。

```
class IShow {
public:
	virtual void show();
}; 

class Person :	public IShow {
public:
	Person(std::string name);
	void show() override{
        printf("我叫：%s\n", _name.c_str());
	}
private:
	std::string _name;
};

class IClothes :public IShow {
public:
	IClothes(IShow* show);
	~IClothes();
	virtual void show() override;
protected:
	IShow* _show;
};

class TShirt :public IClothes {
public:
	TShirt(IShow* show);
	void show()override{
    {
        _show->show();
        printf("穿上了漂亮的T恤,使我更精神！\n");
	}
};

int main() {
	IShow* per = new Person("张三");
	per = new TShirt(per);
	per->show();
}

```

##### 1.2.3 代理模式

在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

```
class IFactory
{
public:
	IFactory(){}
	virtual void makeProduct() = 0;
}


class PhoneFactory : IFactory
{
public:
	PhoneFactory(){}
	void makeProduct()
	{
		cout<<"生产手机"<<endl;
	}
}


class FoxconnProxy : IFactory
{
public:
	FoxconnProxy(IFactory* factory)
	{
		m_real = factory;
	}
	void makeProduct()
	{
		m_real->makeProduct();
	}
private:
	IFactory* m_real;
}

int main(){
    IFactory* factory = new PhoneFactory();
	FoxconnProxy* proxy =  new FoxconnProxy(factory);
	proxy->makeProduct();
}

```

##### 1.2.4 外观模式

外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

```
class SubSystem_0
{
public:
	void method()
	{
		std::cout << "SubSystem_0" << std::endl;
	}
};

class SubSystem_1
{
public:
	void method()
	{
		std::cout << "SubSystem_1" << std::endl;
	}
};

class SubSystem_2
{
public:
	void method()
	{
		std::cout << "SubSystem_2" << std::endl;
	}
};

class Facade
{
private:
	SubSystem_0 * m_pSystem_0;
	SubSystem_1 * m_pSystem_1;
	SubSystem_2 * m_pSystem_2;
public:
	Facade()
	{
		m_pSystem_0 = new SubSystem_0();
		m_pSystem_1 = new SubSystem_1();
		m_pSystem_2 = new SubSystem_2();
	}
	~Facade()
	{
		delete m_pSystem_0;
		delete m_pSystem_1;
		delete m_pSystem_2;
	}
	// 该方法具体怎么调用是根据需求来定
	void method()
	{
		m_pSystem_0->method();
		m_pSystem_1->method();
		m_pSystem_2->method();
	}
};

int main()
{
	Facade * p = new Facade();
	p->method();
}

```

##### 1.2.5 桥接模式

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。

```
//操作系统
class OS
{
public:
	virtual void InstallOS_Imp() {}
};
class WindowOS: public OS
{
public:
	void InstallOS_Imp() { cout<<"安装Window操作系统"<<endl; } 
};
class LinuxOS: public OS
{
public:
	void InstallOS_Imp() { cout<<"安装Linux操作系统"<<endl; } 
};
class UnixOS: public OS
{
public:
	void InstallOS_Imp() { cout<<"安装Unix操作系统"<<endl; } 
};


class Computer
{
public:
	virtual void InstallOS(OS *os) {}
};
class DellComputer: public Computer
{
public:
	void InstallOS(OS *os) { os->InstallOS_Imp(); }
};
class AppleComputer: public Computer
{
public:
	void InstallOS(OS *os) { os->InstallOS_Imp(); }
};
class HPComputer: public Computer
{
public:
	void InstallOS(OS *os) { os->InstallOS_Imp(); }
};


int main()
{
	OS *os1 = new WindowOS();
	OS *os2 = new LinuxOS();
	Computer *computer1 = new AppleComputer();
	computer1->InstallOS(os1);
	computer1->InstallOS(os2);
}

```

##### 1.2.6 组合模式

组合模式，就是将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

```
class ComponentPtr
{
protected:
	std::string m_strName;
public:
	ComponentPtr(std::string str)
	{
		m_strName = str;
	}
	virtual void add(ComponentPtr * p) = 0;
	virtual void remove(ComponentPtr * p) = 0;
	virtual void display() = 0;
};

class LeafPtr : public ComponentPtr
{
public:
	LeafPtr(std::string str) : ComponentPtr(str) {}
	void add(ComponentPtr * p)
	{
		std::cout << "Leaf cannot add" << std::endl;
	}
	void remove(ComponentPtr * p)
	{
		std::cout << "Leaf cannot remove" << std::endl;
	}
	void display()
	{
		std::cout << m_strName << std::endl;
	}
};

class CompositePtr : public ComponentPtr
{
private:
	// 这里使用智能指针不用自己释放new的内存
	std::vector<std::shared_ptr<ComponentPtr>> m_vec;
public:
	CompositePtr(std::string str) : ComponentPtr(str) {};
	~CompositePtr()
	{
		if (!m_vec.empty())
		{
			m_vec.clear();
		}
	}
	void add(ComponentPtr * p)
	{
		auto it = find_if(m_vec.begin(), m_vec.end(), 
			[p](std::shared_ptr<ComponentPtr> ptr) {return p == ptr.get(); });
		if (it == m_vec.end())
			m_vec.push_back(std::shared_ptr<ComponentPtr>(p));
	}
	void remove(ComponentPtr * p)
	{
		auto it = find_if(m_vec.begin(), m_vec.end(),
			[p](std::shared_ptr<ComponentPtr> ptr) {return p == ptr.get(); });
		if (it == m_vec.end())
			return;
		m_vec.erase(it);
	}
	void display()
	{
		for (auto it = m_vec.cbegin(); it != m_vec.cend(); it++)
		{
			(*it)->display();
		}
	}
};

int main()
{
	using namespace std;
	// 组合模式
	CompositePtr * p = new CompositePtr("总部");
	p->add(new LeafPtr("总部财务部门"));
	p->add(new LeafPtr("总部人力资源部门"));
	CompositePtr * p1 = new CompositePtr("上海分部");
	p1->add(new LeafPtr("上海分部财务部门"));
	p1->add(new LeafPtr("上海分部人力资源部门"));
	p->add(p1);
}	//形成一种树状的关系

```

##### 1.2.7享元模式

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

```
class Flyweight  //抽象的享元类
{
public :
	virtual void Operator(int i) = 0;
};
 
class ConcreteFlyweight : public Flyweight  //共享的子类
{
public:
	void Operator(int i)
	{
		cout <<"共享的Flyweight： " << i<<endl;
	}
};


class FlyweightFactory  //享元工厂
{
private: 
	map<string, Flyweight*> flyweights;  //模块名列表
public:
	FlyweightFactory()
	{
		//这里需要用堆，因为这是给客户程序返回的，如果不用堆，则会返回局部对象的引用
		flyweights["x"] = new ConcreteFlyweight();
		flyweights["y"] = new ConcreteFlyweight();
		flyweights["z"] = new ConcreteFlyweight();//所有的属性为“z”的模块都只对应这个一个实例，这正是享元模式的精髓所在呀
	}
	
	Flyweight* GetFlyWeight(string key)
	{
		if (!flyweights.count(key))
			flyweights[key] = new ConcreteFlyweight();
		return flyweights[key];
	}
};

```

#### 1.3行为型模式

##### 1.3.1命令模式

命令模式就是一个函数对象：一个作为对象的函数。通过将函数封装成对象，就可以以参数的方式传递给函数或者其他对象。

```
class Command{
    public:
    	virtual void execute()=0;
}

class open:public Command {
    public:
    	void void execute(){cout<<"i am open!"}
}

class close:public Command {
    public:
    	void void execute(){cout<<"i am close!"}
}

class Macro {
    vector<Command *> commands;
    public:
    	void run(){
            auto it=command.begin();
            while(it!=commands.end()){
                (*it++)->execute();
            }
    	}
}

```

对于类Macro来说就可以接受Command命令，根据具体的命令对象来执行不同的命令。

命令模式的主要特点就是可以通过一个对象或者函数传递一个想要的动作。

##### 1.3.2 中介者模式

中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。

```
class Person
{
protected:
	Mediator *m_mediator; //中介
public:
	virtual void SetMediator(Mediator *mediator){} //设置中介
	virtual void SendMessage(string message) {}    //向中介发送信息
	virtual void GetMessage(string message) {}     //从中介获取信息
};
//抽象中介机构
class Mediator
{
public:
	virtual void Send(string message, Person *person) {}
	virtual void SetA(Person *A) {}  //设置其中一方
	virtual void SetB(Person *B) {}
};
//租房者
class Renter: public Person
{
public:
	void SetMediator(Mediator *mediator) { m_mediator = mediator; }
	void SendMessage(string message) { m_mediator->Send(message, this); }
	void GetMessage(string message) { cout<<"租房者收到信息"<<message; }
};
//房东
class Landlord: public Person
{
public:
	void SetMediator(Mediator *mediator) { m_mediator = mediator; }
	void SendMessage(string message) { m_mediator->Send(message, this); }
	void GetMessage(string message) { cout<<"房东收到信息："<<message; }
};
//房屋中介
class HouseMediator : public Mediator
{
private:
	Person *m_A; //租房者
	Person *m_B; //房东
public:
	HouseMediator(): m_A(0), m_B(0) {}
	void SetA(Person *A) { m_A = A; }
	void SetB(Person *B) { m_B = B; }
	void Send(string message, Person *person) 
	{
		if(person == m_A) //租房者给房东发信息
			m_B->GetMessage(message); //房东收到信息
		else
			m_A->GetMessage(message);
	}
};


int main()
{	
	Mediator *mediator = new HouseMediator();
	Person *person1 = new Renter();    //租房者
	Person *person2 = new Landlord();  //房东
	mediator->SetA(person1);
	mediator->SetB(person2);
	person1->SetMediator(mediator);
	person2->SetMediator(mediator);
	person1->SendMessage("我想在南京路附近租套房子，价格800元一个月\n");
	person2->SendMessage("出租房子：南京路100号，70平米，1000元一个月\n");
	delete person1; delete person2; delete mediator;
	return 0;
}

```

##### 1.3.3 解释器模式

给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。这种模式被用在 SQL 解析、符号处理引擎等。

##### 1.3.4 访问者模式

